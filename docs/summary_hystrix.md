### hystrix 小结

在微服务中，一个请求有可能是多个微服务协同处理的，多个微服务相互依赖。这时候，如果某个服务超时、网络不通，导致调用者阻塞，怎么办？总不能够全部的请求都积压在这一个服务上，占用大量资源，导致系统雪崩吧？

那，如何保护系统呢？一个服务不能用就不能用，不能因为这样，全盘系统都不能用了。

于是：

1. 服务限流：服务消费者限制自身对某一服务能够发起的并发请求数量，超过数量则不调用；
2. 熔断状态：熔断状态下，服务消费者不会发起对某一服务的调用；
3. 服务降级：请求异常情况下，程序执行指定的降级策略（有点儿类似于异常捕获的catch代码块）

好比，在使用淘宝时，如果请求太大，会提示：服务忙，请稍后再试。

嗯，这三个东西要自己实现，还是有些麻烦的。那么，hystrix 就是现成可用的。

如何集成？

1. 引入 spring-cloud-starter-netflix-hystrix 依赖
2. 创建一个类继承 HystrixCommand，重写 fallback 方法；或者使用注解来进行配置...
3. 通过这个类去代理相关请求；
4. 出现问题后执行 fallback；

这儿要注意，熔断是在服务调用者端进行设计哦...

具体的配置，还参考示例...

那么，关于 hystrix 的核心：

1. hystrix 资源隔离的思想
2. 初始化流程
3. 执行流程
4. 和 spring cloud 集成
5. hystrix 的监控 dashboard

![image](/docs/images/hystrix_process_flow.png)

![image](/docs/images/hystrix_command.png)


具体原理，下回分解咯